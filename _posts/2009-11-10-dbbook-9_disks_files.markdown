---
layout: post
status: publish
published: true
title: ! 'Database Management Systems 9章: Disks and Files'
author: tjun
author_login: tjun
author_email: t.junichiro@gmail.com
author_url: http://tjun.jp/blog/
wordpress_id: 127
wordpress_url: http://tjun.jp/blog/?p=127
date: 2009-11-10 23:32:49.000000000 +09:00
categories:
- db
tags:
- db
comments: []
---
データベースの本を読んでまとめる作業のついでにブログに書いちゃいます。
読んでるのはこの本

<iframe src="http://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=tjun-22&o=9&p=8&l=as1&m=amazon&f=ifr&md=1X69VDGQCMF7Z30FM082&asins=0071230572" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>

データベースの基本がしっかりと書かれている有名な本。らしい。結構でかいです。
いきなり9章から始めます。

自分の理解は間違ってるかもしれません。あまり自信なし。
<h1>9章：Disks and Files</h1>
DBMSではデータをどうやって蓄えるか。ディスクマネージメント，バッファマネージメントなどの話．
<h2>■メモリー階層</h2>
（CPU ）- キャッシュ - メインメモリ - 磁気ディスク - （テープ）
アクセス：　　速い&rarr;遅い
容量当たりの値段：　高い&rarr;安い
電源切ったら：　データ消える&rarr;消えない（不揮発性）

DBMSを使うことで，データがメモリにあるのかディスクにあるのか，などを意識しなくてよくなる．
メモリだけでは全てのデータを格納しきれないから，ディスクが必要．
<h2>■磁気ディスク</h2>
いろいろな部分の名前がややこしい。図を見て理解する
http://images.google.co.jp/images?gbv=2&amp;hl=ja&amp;q=disk+track+block+sector+platter&amp;sa=N&amp;start=20&amp;ndsp=20
<ul>
	<li>データはディスクブロックという単位でディスクに読み書きされる。ディスクブロックは連続したバイトの並び</li>
	<li>これがトラックと呼ばれるプラッター上の輪っかに並ぶ（図参照）．プラッターはハードディスク内の円盤上のやつで，両面にデータを持てる．</li>
	<li>同じ直径を持つトラックのセットをシリンダーという．（=シリンダーはプラッターの表面にトラックを持つ）</li>
	<li>トラックは，セクターとよばれる固有の単位に分けられる．ディスクブロックは，セクターn個分と最初にサイズが決められる．</li>
	<li>ディスクヘッドとは，データの読み書きのときブロックの頭に位置する．プラッターの両面の数だけ存在し，一体となって動く（図参照）</li>
	<li>チェックサムは，セクターがおかしかったり読み込みに失敗したりするのをチェックするのに用いられる．</li>
	<li>データを処理するには一度ディスクからメモリに置く必要がある。</li>
	<li>I/Oは，たとえアイテム1つのためでもブロック単位で行われる．</li>
</ul>
<h3>・ディスクアクセスに要する時間とは，seek time + rotational delay + transfer time</h3>
<ul>
	<li>seek time: ディスクヘッドが目的のブロックがある「トラックの位置」まで動くのにかかる時間。プラッタがでかいとその分かかる</li>
	<li>rotational delay: ブロックがディスクヘッドのところに来るまで回ってくるのにかかる時間．平均で半周回る。seek timeより短い。</li>
	<li>transfer time: データのブロックへの読み書きにかかる時間．</li>
</ul>
だから，読み書きにかかる時間を減らすには，データをディスクのどこに置くのか，というのが重要．
同時に読み書きされるものは，固めておいておくべき．
データの近さは
同じブロック　＞　同じトラック　＞　同じシリンダ　＞　近いシリンダ

シーケンシャルに読み書きされるデータはシーケンシャルに置いておけ．
<h2>■データストライピングと冗長化</h2>
ストライピングするとI/Oが速くなって，冗長化すると信頼性が上がる．
RAID: redundant arrays of independent disks
<h3>ストライピング</h3>
<ul>
	<li>データを同じサイズに分割して複数のディスクに分散．このサイズをストライピングユニットという．</li>
	<li>ラウンドロビンで分散．</li>
</ul>
<h3>冗長化</h3>
ディスクのMTTF(平均故障寿命)が5年で100枚ディスクがあれば21日に1つ壊れる．
- 冗長化情報を持つことで，データの再構築ができる．冗長化情報はいくつかのディスクに置いておく
- パリティ情報を蓄える
RAIDではデータディスクとチェックディスクを作る．チェックディスクの数はRAIDレベルによる．

RAID0はパフォーマンスがあがるだけ．
RAID0+1はあまりストレージがいらないシステムや書込が多いアプリケーション向け
RAID2とRAID4はRAID3,RAID5に劣る
RAID3はまとまったブロックの読み書きが多い場合によい
RAID5はいろんな用途につかえる
RAID6はより信頼性が欲しいとき
<h2>■ディスクスペースマネージメント</h2>
<ul>
	<li> ページ単位でデータを扱い，ディスクスペースの割り当て，解放，読み書きを行う．</li>
	<li>ページの読み書きが一度のディスクI/Oに対応するため，ページの大きさはディスクブロックに等しく，ディスクブロックとして書き込まれる</li>
	<li>ディスクスペースマネージャによって，これより上の層はハードのことは気にせずページの読み書きをやっていればよい</li>
	<li>データの読み書きを繰り返していると，ディスクスペースにデータのない部分(holes)ができてしまう</li>
	<li>フリーなブロックのリストを作るか，それぞれのブロックが使用かどうかのビットマップを持つかして，このfree blocksの管理をする．</li>
</ul>
<h3>・OSも連続したバイトをファイルとして扱うことができる</h3>
ファイルf の i バイト目を読む　＝　ディスクd のシリンダーc のトラックt のブロックm を読む　と対応させる．
ディスクスペースマネージャはOSのファイルを使ってつくることができる．

多くのデータベースはそうしないで，ディスクスペースマネージャを自前で用意するか，OSの機能を拡張するかして実現する
なぜなら，多くの環境で動くものにしたいから，自己完結するコードにしたい，32ビットシステムでは4GBまでのファイルサイズしか扱えない，ディスクをまたがってデータを扱いたい，などの理由がある．
<h2>■バッファマネージャ</h2>
必要な分だけディスクからメモリにデータを持ってくる．メモリ上（バッファプールと呼ばれる領域）をページ単位で区切って，ページを読み込んだりする．バッファプール内のページ単位のスロットをフレームという．
これより上の層はページがメモリ上にあるかどうかを気にしなくていい．問い合わせ，返還，変更の通知　を行うだけ．

それぞれのフレームに対してdirtyとpin count　という２つの変数を持つ．
<ul>
	<li> dirty：ページに変更があったかどうか</li>
	<li>pin count：最初０．その時のページのリクエストの数</li>
</ul>
<ul>
	<li>ページリクエストがあると，まずはフレームから代わりに出て行って貰うモノを探し，pin countをふやす（pinning）</li>
	<li>dirtyビットがonならディスクに書く</li>
	<li>あけたところにページを読み込む</li>
	<li>そのページを持つフレームのアドレスを返す</li>
	<li>解放されたらpin countを減らす(unpinning)</li>
	<li>修正したらunpinでdirty on</li>
	<li>pin countが0でなければページはそのままフレームにとどまる</li>
	<li>pin countが0のなかで，どのフレームを入れ替えるかはルールがある</li>
	<li>修正されていないもの：ディスクに書き込む必要がないからフレームに上書きできる</li>
	<li>pin count =0 がないなら，待つか，トランザクションを禁止して割り当てる</li>
	<li>異なるトランザクション：衝突（不整合）を生み出すから，同時には割り当てない（排他的ロック）</li>
</ul>
<h3>・フレーム入れ替えルール</h3>
<ul>
	<li> LRU: least recently used</li>
</ul>
pin count０のフレームへのポインタのキュー
<ul>
	<li> clock:　キューではなくて，時計のような円にフレームをみなし，pinが0のものはリファレンスビットが１になっている</li>
</ul>
時計の針のようなもので見ていく．pinが０でビットが１なら0にする．pinが０，ビットも０なら入れ替えへ．これは最近参照されたページはなるべく残すため
<ul>
	<li>FIFOやmost recently used もある</li>
</ul>
<h2>■バッファマネージメント vs OS</h2>
バッファマネージメントとOSの仮想メモリは似てる
なぜ仮想メモリを使わないかというと，DBMSは次に参照されるデータなどをある程度予測し，先に読み込んでおくといったことをやることで，より速くデータを用意でき，また同じページに対する参照をまとめることもできるので，仮想メモリより高速なデータの参照を実現できる．また，CPUも先にディスクI/Oを指示して次の仕事に回れる

また，ディスク上のページをメモリ上のページに同期させておきたい
<h2>■file of records</h2>
ファイル：ページのセット，コレクション
ファイルの中には同じサイズのページが並び，レコードはそれぞれridを持つ
ファイルに対しての作成と削除，レコードの挿入と削除，ridを指定したデータの取得，全てのデータのスキャン　ができる

それぞれのファイルのページと空きスペースを含むページを把握する必要がある．
ページはファイルの中での索引付けのために２つのポインタを記憶する必要がある．
<h2>■ページ管理手法</h2>
・線形リスト：双方向の線形リストとしてページを管理，全てのページのリストとフリースペースを持つページのリストの2つのリストを持つ．
DBMSはヒープファイルの名前とそのヘッダファイルへのアドレスを記憶している．
新たなページが必要になる場合，ディスクスペースマネージャにリクエストして得たページをリストに追加する．
可変長のレコードの場合ほとんとのページがフリーリストに行ってしまうという欠点がある．

・ディレクトリ
ページのコレクション（セット）がディレクトリで，それがリストを作る．ディレクトリのエントリはそれぞれがページを示す．
DBMSはそれぞれのファイルの頭のディレクトリを把握している．
フリースペースの把握には，エントリ毎の空きスペースのあるなしのビット，あるいはフリースペースの量を示すカウントを保持する．
<h2>■ページフォーマット</h2>
ページはレコードを持つスロットのセット
レコードはページのidとスロットナンバー（rid）で特定できる．
<h3>・固定長のレコード</h3>
固定長であればレコードのあるなしの管理だけ．あいてるところを探して新たなモノをいれる．あいてるスロットの管理が重要．
１つめの方法：前からつめていく．途中があいたら一番後ろのレコードをそこに移す．それぞれのレコードがオフセットで表現可能．
動いたレコードにアクセスがくるとよくない
<h3>・可変長のレコード</h3>
<ul>
	<li>ページ内の空きスペースをつなげて連続させる．どうやってレコードを移動するかが大事．</li>
	<li>ページ毎のスロットディレクトリ（レコードオフセットとレコードの長さ）を持つのがいい．</li>
	<li>レコードオフセットはレコードへのポインタ．消すのはポインタを-1にする．</li>
	<li>ページ内ではridは変わらないので自在に動かせる．</li>
	<li>フリースペースの管理には，フリースペースの頭へのポインタを持つ．</li>
	<li>スロットの途中が消えても，スロットナンバーの入れ替えが必要になるならそのままスロットディレクトリには残る．次にきたレコードに使う．</li>
</ul>
<h2>■レコードフォーマット</h2>
<ul>
	<li>レコードも固定長と可変長で扱いが異なる．</li>
	<li>どちらの場合もフィールド数は固定</li>
	<li>フィールドの情報はシステムカタログに置いておく</li>
</ul>
<h3>固定長レコードの場合</h3>
<ul>
	<li>長さとフィールド数が固定</li>
	<li>フィールドの長さから各フィールドへのアドレスが分かる</li>
</ul>
<h3>可変長レコードの場合</h3>
<ul>
	<li>レコードフォーマットフィールド数は固定，いくつかが可変長のフィールド</li>
	<li></li>
	<li>フィールドをデリミタで区切る</li>
	<li>レコードの頭にフィールドへのオフセット配列を持つ（レコード終端へのオフセットも入る）</li>
</ul>
オーバーヘッドがあるが後者の方がダイレクトにアクセスできるのでよい
ヌルはスペースを使わない（２つのフィールドへのポインタが同じになる）
